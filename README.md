# FileSystemIntegrity.sh
Source: "Cybersecurity Ops with bash: Attack, Defend, and Analyze from the Command Line" Paul Troncone

# Лабораторная работа по дисциплине: Комплексное обеспечение защиты информации объекта информатизации
Установка и настройка средств контроля целостности данных

## Check the integrity of the file system #1
```Shell 
function usageErr(){         # Функция, отвечающая за вызов ошибки
	echo 'usage: baseline.sh [-d path] file1 [file2]'
	echo 'creates or compares a baseline from path'
	echo 'default for path is /'
	exit 2               # Exit 2 - выйти из программы (скрипта), на основании ошибки
} >&2                        # >&2 - весь вывод перенаправляется в поток stderr  


: '
DIR у нас является массивом из названий каталогов, что видно тут (declare -a, по сути -array), 
который в сумме образуют директорию -type f опция, для поиска только файлов. 
Xargs - позволяет производить операции над переданными файлами, которые пришли из find.
Существует встроенная опция в find -exec, но данное решение нам не подходит, 
ибо этот вариант выполняет операцию при каждой "итерации",
а xargs выполняет операцию хеширования сразу над >1000 файлами
'
function dossuming () {
	find "${DIR[@]}" -type f | xargs -d '\n' sha1sum
}

declare -a DIR


: '
Команда getopts - парсер опций + аргументов.
Синтаксис (getopts optstring name)
В переменной optstring хранятся все возможные опции.

В случае, если нам нужно передать аргумент в опцию, мы должны обозначить это с помощью : 
, в нашем случае мы передаем опции -d (directory) аргумент, следовательно "d:"

Shift $((OPTIND-1)) - Команда getopts использует переменную оболочки optind,
которая указывает на индексы переданных в программу аргументов.
По сути наша команда возвращает в искомое положение наш "указатель". То есть наш указатель будет снова равен 1
'
while getopts "d:" MYOPT
do
	DIR+=("$OPTARG")
done
shift $((OPTIND-1))


: '
Тут мы проверяем, были ли переданы аргументы file1 + file2, а также проверяем, чтобы количество аргументов было не более 2. 
В случае, если проверка проходит удачно (то есть аргументы не были переданы или их кол-во превышает 2), 
условный оператор && переводит нас к функции вызова ошибки.
'
(( $# == 0 || $# > 2 )) && usageErr


: '
{#DIR[*]} - возвращает количество элементов в массиве

Оператор && переходит ко второму выражению, только в том случае, если первое истинно, то бишь равно 0
'
(( ${#DIR[*]} == 0 )) && DIR=( "/" )

BASE="$1"
B2ND="$2"
```

## Check the integrity of the file system #2
```shell
: '
В данном куске кода, мы руководствуемся логикой "в случае если мы передали один аргумент, 
значит - мы хотим создать файл актуальных хешей файлов той директории, 
которую мы указали в качестве аргумента опции -d" 
'
if (( $# == 1 ))
then
	dossuming > "$BASE"
	exit
fi


: '
[[ ! -r "$BASE" ]] - Флаг -r проверяет наличие файла и является ли он readable! 
Следовательно, мы проверяем ложен ли факт существования нашего файла, если да - то вызываем функцию usageErr, иначе - ничего)
Данный кусок кода необходим, дабы проверить насколько пользователь нашей программы честен с нами.
'
if [[ ! -r "$BASE" ]]	
then 
	usageErr
fi


: '
[[ ! -e "$B2ND" ]] - флаг -e проверяет наличие файла. 
В случае, если файл не существует, то мы создаем его!
'
if [[ ! -e "$B2ND" ]]
then 
	echo creating "$B2ND"
	dossuming > "$B2ND"
fi

# Объявляем переменные, которые будут ассоциативными массивами (a.k.a словарь ). A[0]=1, b[2]=10 …
declare -A BYPATH BYHASH INUSE


: '
Данный кусок кода предназначен для сбора информации из первого файла

BYPATH["$FN"]=$HNUM - переменная находящаяся под "ключём", 
который является названием файла и в качестве значения принимает значение хеша этого файла

BYHASH[$HNUM]="$FN" - соответствие ХЕШ --> Имя файла

INUSE["$FN"]="X" - присваивает ключу значение Х, по сути данная переменная предназначена для валидации факта наличия файла
'
while read HNUM FN
do
	BYPATH["$FN"]=$HNUM
	BYHASH[$HNUM]="$FN"
	INUSE["$FN"]="X"
done < "$BASE"
```

## Check the integrity of the file system #3
```shell 
: '
Данный фрагмент кода анализирует данные на основании двух файлов. 

Логика такова - в качестве ключей HNUM и FN у нас выступают теперь данные из 2-го файла "$B2ND". 
Мы создаём переменные WASHASH и ALTFN, которым мы будем присваивать значение переменных BYHASH и BYPATH из 1-го файла 
В СООТВЕТСТВИИ С КЛЮЧАМИ ВТОРОГО ФАЙЛА
'
printf '<filesystem host="%s" dir="%s">\n' "$HOSTNAME" "${DIR[*]}"

while read HNUM FN
do
  : '
  WASHASH="${BYPATH[${FN}]}" - значением этой переменной будет являться ХЭШ файла, 
  название которого мы считываем из "$B2ND"

  if [[ -z $WASHASH ]] - проверяем, является ли значение переменной WASHASH ненулевым
  '
	WASHASH="${BYPATH[${FN}]}"
	if [[ -z $WASHASH ]]
	then
    : '
    Если оно нулевое, тогда нужно проверить… 
    Может название файла было изменено, но содержание осталось тем же
    
    Значит теперь мы будем искать соответствие по хешу
    
    $ALTFN="${BYHASH[$HNUM]}" - значением этой переменной будет являться название файла, 
    которому соответствует хеш, который мы считываем из "$B2ND"

    Далее проверяем, является ли значение ALTFN ненулевым
    '
		ALTFN="${BYHASH[$HNUM]}"
		if [[ -z $ALTFN ]]
    : '
    Если значение нулевое, значит мы раннее не встречались с этим файлом, 
    раз мы не смогли провести соответствие ни по ХЕШУ, ни по названию ФАЙЛА

    Если значение ненулевое, то в таком случае мы делаем вывод, что файл был перемещён
    INUSE["ALTFN"]='_' - по окончанию анализа файла, нам необходимо отметить, что он нам встретился.
    Это необходимо для дальнейшего определения того, какие файлы были удалены
    '
		then
			printf '	<new>%s</new>\n' "$FN"
		else
			printf '	<relocated orig="%s">%s</relocated>\n' "$ALTFN" "$FN"
			INUSE["$ALTFN"]='_'
		fi
	else
    : ' 
    Если значение ненулевое, то первым делом, нужно отметить факт того, что нам встретился файл.
    А уже после нам нужно сравнить хеши исходя из данных файлов $BASE'а и $B2ND'а. 
    Поэтому мы сравниваем значение переменной $WASHASH (в которой находится значение хеша файла из $BASE) 
    со значением переменной $HNUM (в которой находится значение хеша файла из $B2ND)

    В случае, если хеши равны - идём дальше.
    Иначе отмечаем, что хеш файла был изменен, следовательно!
    '
		INUSE["$FN"]='_'
		if [[ $HNUM == $WASHASH ]]
		then
			continue;
		else
			printf '	<changed>%s</changed>\n' "$FN"
		fi
	fi	
done < "$B2ND"

# А тут мы проверяем удалили ли мы файл или нет
for FN in "${!INUSE[@]}"
do
	if [[ "${INUSE[$FN]}" == 'X' ]]
	then
		printf '	<removed>%s</removed>\n' "$FN"
	fi
done

printf '</filesystem>\n'
```
